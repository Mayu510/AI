2. Implement A star (A*) Algorithm for any game search problem.

def a_star(start, goal):
    # Define possible moves (up, down, left, right)
    moves = [(0,1), (1,0), (0,-1), (-1,0)]
    # Simple grid: 0 = free path, 1 = obstacle
    grid = [
        [0, 0, 0, 0],
        [1, 1, 0, 1],
        [0, 0, 0, 0],
        [0, 1, 1, 0],
        [0, 0, 0, 0]
    ]

    # Heuristic function (Manhattan distance)
    def h(p1, p2):
        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])

    # Open list and closed list
    open_list = [(start, [start], 0)]  # (current, path, cost)
    closed_list = []

    while open_list:
        # Sort by total cost (path cost + heuristic)
        open_list.sort(key=lambda x: x[2] + h(x[0], goal))
        current, path, cost = open_list.pop(0)
        if current == goal:
            return path  # Found path
        closed_list.append(current)
        for move in moves:
            x, y = current[0] + move[0], current[1] + move[1]

            # Check valid position
            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0:
                next_pos = (x, y)
                if next_pos not in closed_list:
                    open_list.append((next_pos, path + [next_pos], cost + 1))

    return None  # No path found
# Example usage
start = (0, 0)
goal = (4, 3)
result = a_star(start, goal)

print("Shortest Path:", result)
